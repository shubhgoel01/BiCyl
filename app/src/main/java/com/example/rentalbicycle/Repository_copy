package com.example.rentalbicycle

import android.util.Log
import android.widget.Toast
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.remember
import androidx.compose.runtime.setValue
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.ktx.auth
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ktx.database
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext

//in user, i am only storing the list of id of nodes of schedules. Whenever
//user creates a new schedule, a Schedule object is created containing all detailes,
//and and the Schedule object id is passed to user and cycle.



class Repository {
    var auth: FirebaseAuth = Firebase.auth      //created firebaseAuthentication variable
    var database: FirebaseDatabase = Firebase.database      //created firebase variable
    var studentState by mutableStateOf(studentDataState())

    fun checkStudentExist(registrationNumber: String, password: String) {
        Log.d("Login","Entered Registration Number $registrationNumber")
        val refStudents = database.reference.child("students").child(registrationNumber)

        refStudents.get().addOnSuccessListener { snapshot ->
            if (snapshot.exists()) {
                val student = snapshot.getValue(Student::class.java)
                if (student != null) {
                    Toast.makeText(
                        auth.app.applicationContext,
                        "Student Validated Successfully",
                        Toast.LENGTH_SHORT
                    ).show()
                    CoroutineScope(Dispatchers.Main).launch {
                        signInUser(registrationNumber,password) // Authentication successful
                    }

                }
            } else {
                Toast.makeText(
                    auth.app.applicationContext,
                    "User Not Allowed",
                    Toast.LENGTH_SHORT
                ).show()// Student does not exist
            }
        }
            .addOnFailureListener {
            Log.e("Student Check", "Error Occurred While Checking For The User")
             // Handle failure, e.g., network issues
        }
    }

    suspend fun get_Student_From_Uid(uid:String):Student?= withContext(Dispatchers.IO){
        var student:Student?=null
        Log.d("Student Data","UID $uid")
        try{
            val snapshot=database.reference.child("roll_to_uid_map").child(uid).get().await()
            Log.d("Student Data", "Snapshot data ${snapshot.toString()}")
            val studentref=snapshot.getValue(String::class.java)
            Log.d("Student Data", "Class ${ studentref.toString() }")
            if(studentref!=null)
            {
                val registrationNumber=studentref
                Log.d("Student Data", registrationNumber)
                student=getStudentData(registrationNumber)
            }
            studentState.copy(
                isLoading = false,
                error = false,
                student=student!!
            )
        }
        catch (exception:Exception)
        {
            Log.e("DataRead", "Failed to read data", exception)
            studentState.copy(
                isLoading = false,
                error = true,
                errorMessage = "Failed to read registration number from firebase Uid"
            )
        }
        return@withContext student
    }


    suspend fun getStudentData(registrationNumber: String): Student? = withContext(Dispatchers.IO) {
        try {
            Log.d("Student Data","Registration Number  $registrationNumber")
            val refStudents = Firebase.database.reference.child("students").child(registrationNumber)
            val snapshot = refStudents.get().await() // Use Kotlin Coroutine's await
            if (snapshot.exists()) {
                snapshot.getValue(Student::class.java)
            } else {
                null
            }
        } catch (exception: Exception) {
            Log.e("DataRead", "Failed to read data", exception)

            null
        }
    }


    suspend fun createNewUser(student: Student, password: String) = withContext(Dispatchers.IO) {
        try {
            Log.e("Register", "Student email - ${student.email}")
            Log.e("Register", "Student password - $password")

            val authResult = auth.createUserWithEmailAndPassword(student.email.toString(), password).await()
            //once authentication completed firebase automatically log in with the email, hence current user is updated

            if (authResult.user != null) {
                Log.e("Register", "Register Successful")
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        auth.app.applicationContext,
                        "User Created Successfully.",
                        Toast.LENGTH_SHORT
                    ).show()
                }

                addToDatabase(student)
            }
        } catch (e: Exception) {
            Log.e("Register", "Register error - ${e.message}")
            withContext(Dispatchers.Main) {
                Toast.makeText(
                    auth.app.applicationContext,
                    "Authentication Failed: ${e.message}",
                    Toast.LENGTH_LONG
                ).show()
            }
        }
    }

    suspend fun addToDatabase(student: Student) = withContext(Dispatchers.IO) {
        auth.currentUser?.let { user ->
            val userRef = database.reference.child("Users").child(user.uid)
            val rollMapRef = database.reference.child("roll_to_uid_map").child(user.uid)

            try {
                userRef.setValue(user(student.registrationNumber, emptyList())).await()
                rollMapRef.setValue(student.registrationNumber).await()
                Log.e("Register", "User and Roll-to-UID map added successfully")
            } catch (e: Exception) {
                Log.e("Register", "Failed to add user data: ${e.message}")
            }
        }
    }

    suspend fun signInUser(registrationNumber: String, password: String) {
        val student = getStudentData(registrationNumber)

        student?.email?.let {
            try {
                auth.signInWithEmailAndPassword(it, password).await()
                withContext(Dispatchers.Main) {
                    Toast.makeText(auth.app.applicationContext, "SignIn Successful.", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Log.e("SignIn", "User does not exist: ${e.message}")
                createNewUser(student, password)
            }
        }
    }
}

------------------------------------------------------------------------------------------------
version 2
package com.example.rentalbicycle

import android.util.Log
import android.widget.Toast
import androidx.compose.runtime.getValue
import androidx.compose.runtime.mutableStateOf
import androidx.compose.runtime.setValue
import com.google.android.play.integrity.internal.i
import com.google.firebase.auth.FirebaseAuth
import com.google.firebase.auth.ktx.auth
import com.google.firebase.database.DataSnapshot
import com.google.firebase.database.DatabaseError
import com.google.firebase.database.FirebaseDatabase
import com.google.firebase.database.ValueEventListener
import com.google.firebase.database.getValue
import com.google.firebase.database.ktx.database
import com.google.firebase.ktx.Firebase
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.tasks.await
import kotlinx.coroutines.withContext

//in user, i am only storing the list of id of nodes of schedules. Whenever
//user creates a new schedule, a Schedule object is created containing all details,
//and and the Schedule object id is passed to user and cycle.



class Repository {
    var auth: FirebaseAuth = Firebase.auth // Firebase Authentication

    var database: FirebaseDatabase = Firebase.database // Firebase Database
    var userRef = auth.currentUser?.let { database.reference.child(it.uid) }
    var studentState by mutableStateOf(studentDataState())
    var currentUser: user by mutableStateOf(user())
    private var scheduleListString: List<String> by mutableStateOf(emptyList())
    var scheduleState by mutableStateOf((schedulesDataState()))


    fun checkStudentExist(registrationNumber: String, password: String) {
        Log.d("Login", "Entered Registration Number $registrationNumber")
        val refStudents = database.reference.child("students").child(registrationNumber)

        refStudents.get().addOnSuccessListener { snapshot ->
            if (snapshot.exists()) {
                val student = snapshot.getValue(Student::class.java)
                if (student != null) {
                    Toast.makeText(
                        auth.app.applicationContext,
                        "Student Validated Successfully",
                        Toast.LENGTH_SHORT
                    ).show()
                    CoroutineScope(Dispatchers.Main).launch {
                        signInUser(registrationNumber, password)
                    }
                }
            } else {
                studentState = studentState.copy(
                    isLoading = false,
                    error = true,
                    errorMessage = "User Not Allowed"
                )
                Toast.makeText(
                    auth.app.applicationContext,
                    "User Not Allowed",
                    Toast.LENGTH_SHORT
                ).show()
            }
        }.addOnFailureListener { exception ->
            studentState = studentState.copy(
                isLoading = false,
                error = true,
                errorMessage = "Error occurred while checking for the user: ${exception.message}"
            )
            Log.e("Student Check", "Error occurred while checking for the user", exception)
        }
    }

    suspend fun get_Student_From_Uid(uid: String) = withContext(Dispatchers.IO) {
        Log.d("Student Data", "UID $uid")
        try {
            val snapshot = database.reference.child("roll_to_uid_map").child(uid).get().await()
            Log.d("Student Data", "Snapshot data $snapshot")
            val registrationNumber = snapshot.getValue(String::class.java)

            Log.d("Student Data", "Registration Number ${registrationNumber.toString()}")
            if (!registrationNumber.isNullOrEmpty()) {
                getStudentData(registrationNumber)

            } else
                studentState = studentState.copy(
                    isLoading = false,
                    error = false,
                    errorMessage = "registrationNumber is null or empty"
                )

        } catch (exception: Exception) {
            Log.e("DataRead", "Failed to read data", exception)
            studentState = studentState.copy(
                isLoading = false,
                error = true,
                errorMessage = "Failed to read registration number from Firebase UID $exception"
            )
        }
    }

    private suspend fun getStudentData(registrationNumber: String) = withContext(Dispatchers.IO) {
        Log.d("Student Data", "Registration Number $registrationNumber")
        try {
            val refStudents =
                Firebase.database.reference.child("students").child(registrationNumber)
            val snapshot = refStudents.get().await()
            if (snapshot.exists()) {
                val student = snapshot.getValue(Student::class.java)
                studentState = if (student != null) {
                    studentState.copy(
                        isLoading = false,
                        error = false,
                        student = student
                    )
                } else {
                    studentState.copy(
                        error = true,
                        errorMessage = "Error while fetching data while de-referencing"
                    )
                }
            }
        } catch (exception: Exception) {
            Log.e("DataRead", "Failed to read data", exception)
            studentState = studentState.copy(
                isLoading = false,
                error = true,
                errorMessage = "Failed to read student data"
            )
        }
    }

    private suspend fun createNewUser(student: Student, password: String) =
        withContext(Dispatchers.IO) {
            Log.e("Register", "Student email - ${student.email}")
            try {
                val authResult =
                    auth.createUserWithEmailAndPassword(student.email, password).await()
                if (authResult.user != null) {
                    Log.e("Register", "Register Successful")
                    withContext(Dispatchers.Main) {
                        Toast.makeText(
                            auth.app.applicationContext,
                            "User Created Successfully.",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                    addToDatabase(student)
                }
            } catch (e: Exception) {
                Log.e("Register", "Register error - ${e.message}")
                studentState = studentState.copy(
                    isLoading = false,
                    error = true,
                    errorMessage = "Authentication Failed: ${e.message}"
                )
                withContext(Dispatchers.Main) {
                    Toast.makeText(
                        auth.app.applicationContext,
                        "Authentication Failed: ${e.message}",
                        Toast.LENGTH_LONG
                    ).show()
                }
            }
        }

    private suspend fun addToDatabase(student: Student) = withContext(Dispatchers.IO) {
        auth.currentUser?.let { user ->
            val userRef = database.reference.child("Users").child(user.uid)
            val rollMapRef = database.reference.child("roll_to_uid_map").child(user.uid)
            try {
                val default_list = listOf("Default")
                userRef.setValue(user(student.registrationNumber, default_list)).await()
                rollMapRef.setValue(student.registrationNumber).await()
                Log.e("Register", "User and Roll-to-UID map added successfully")
            } catch (e: Exception) {
                Log.e("Register", "Failed to add user data: ${e.message}")
                studentState = studentState.copy(
                    isLoading = true,
                    error = true,
                    errorMessage = "Failed to add user data"
                )
            }
        }
    }

    suspend fun add_new_schedule(
        cycle: Cycle,
        prevTimeSlot: MutableList<String>,
        newTimeSlot: MutableList<String>
    ) {
        val cycleUid = database.reference.child("cycleIdToUId").child(cycle.CycleId).get().await()
            .getValue(String::class.java)
        val newSchedule =
            Schedule(auth.currentUser!!.uid, cycleUid!!, newTimeSlot[0], newTimeSlot[1])

        val scheduleRef = database.reference.child("Schedule")
        val cycleRef = database.reference.child("Cycle").child(cycleUid)

        val newScheduleUID = scheduleRef.push().key
        scheduleRef.child(newScheduleUID!!).setValue(newSchedule).await()

        // Correctly update the lists
        val updatedCycleList = cycle.scheduleList.toMutableList().apply {
            add(newScheduleUID)
        }
        val updatedUserScheduleList = currentUser.scheduleList.toMutableList().apply {
            add(newScheduleUID)
        }

        // Handle the available time slots
        val updatedAvailableTimeList = cycle.availableTime.toMutableList()
        updatedAvailableTimeList.remove(prevTimeSlot)


        if (prevTimeSlot[0].toInt() < newTimeSlot[0].toInt()) {
            val remainingStartTime = prevTimeSlot[0]
            val remainingEndTime = newTimeSlot[0]
            updatedAvailableTimeList.add(mutableListOf(remainingStartTime, remainingEndTime))
        }
        if (prevTimeSlot[1].toInt() > newTimeSlot[1].toInt()) {
            val remainingStartTime = newTimeSlot[1]
            val remainingEndTime = prevTimeSlot[1]
            updatedAvailableTimeList.add(mutableListOf(remainingStartTime, remainingEndTime))
        }

        // Save the updated lists to the database
        cycleRef.child("availableTime").setValue(updatedAvailableTimeList).await()
        cycleRef.child("scheduleList").setValue(updatedCycleList).await()
        database.reference.child("Users").child(auth.currentUser!!.uid).child("scheduleList").setValue(updatedUserScheduleList).await()
    }


    private suspend fun signInUser(registrationNumber: String, password: String) =
        withContext(Dispatchers.IO) {

            getStudentData(registrationNumber)
            try {
                studentState.student.email.let {
                    auth.signInWithEmailAndPassword(it, password).await()
                    withContext(Dispatchers.Main) {
                        Toast.makeText(
                            auth.app.applicationContext,
                            "SignIn Successful.",
                            Toast.LENGTH_SHORT
                        ).show()
                    }
                }
            } catch (e: Exception) {
                Log.d("User", "New User: creating New database instance")
                createNewUser(studentState.student, password)
            }
        }

suspend fun get_schedule_list_from_schedule_List_String(uid: String) =
    withContext(Dispatchers.IO) {
        Log.d("Student Data", "UID $uid")
        try {
            get_schedule_list_string_from_uid(uid)
            val snapshot = database.reference.child("Schedule")
            Log.d("Student Data", "Snapshot data $snapshot")

            for (it in scheduleListString.drop(1)) {  // drop(1) skips the first element
                val schedule = snapshot.child(it).get().await().getValue(Schedule::class.java)
                scheduleState = scheduleState.copy(
                    scheduleDataList = scheduleState.scheduleDataList + (schedule
                        ?: continue)  // Safely add schedule to the list
                )
            }

            scheduleState = scheduleState.copy(
                isLoading = false
            )
        } catch (exception: Exception) {
            Log.e("DataRead", "Failed to read schedule", exception)
            scheduleState = scheduleState.copy(
                isLoading = false,
                error = true,
                errorMessage = "Error Occurred while fetching schedule"
            )
        }
    }

private suspend fun get_schedule_list_string_from_uid(uid: String) {
    try {
        val user = database.reference.child("users").child(uid).get().await()
            .getValue(user::class.java)
        if (user != null) {
            currentUser=user
            scheduleListString = user.scheduleList
        }
    } catch (e: Exception) {
        Log.d(
            "Student Data",
            "Error Occurred while retrieving schedule_list_string_from_uid $e"
        )
    }

}

suspend fun getCycles():MutableList<Cycle>?
{
    var allCyclesData: MutableList<Cycle> = mutableListOf()

    val cycleref = database.reference.child("Cycle").get().await()
    var cycleList: List<Cycle>? = null

    if (cycleref.exists()) {
        cycleList = cycleref.children.mapNotNull { it.getValue(Cycle::class.java) }
    }

    if (cycleList != null) {
        for (cycles in cycleList) {
            // Process each cycle object here
            Log.d("Cycles", cycles.CycleId)
            allCyclesData.add(cycles)
        }
    }
    if(allCyclesData.isEmpty())
        return null
    else return allCyclesData
}
}
//    suspend fun getCycles():MutableList<Cycle>?
//    {
//        var allCyclesData: MutableList<Cycle> = mutableListOf()
//
//        val cycleref = database.reference.child("Cycle").get().await()
//        var cycleList: List<Cycle>? = null
//
//        if (cycleref.exists()) {
//            cycleList = cycleref.children.mapNotNull { it.getValue(Cycle::class.java) }
//        }
//
//        if (cycleList != null) {
//            for (cycles in cycleList) {
//                // Process each cycle object here
//                Log.d("Cycles", cycles.CycleId)
//                allCyclesData.add(cycles)
//                }
//            }
//        if(allCyclesData.isEmpty())
//                return null
//        else return allCyclesData
//    }
//-------------------------------------------
//suspend fun get_schedule_list_from_schedule_List_String(uid: String) =
//    withContext(Dispatchers.IO) {
//        Log.d("Student Data", "UID $uid")
//        try {
//            get_schedule_list_string_from_uid(uid)
//            val snapshot = database.reference.child("Schedule")
//            Log.d("Student Data", "Snapshot data $snapshot")
//
//            for (it in scheduleListString.drop(1)) {  // drop(1) skips the first element
//                val schedule = snapshot.child(it).get().await().getValue(Schedule::class.java)
//                scheduleState = scheduleState.copy(
//                    scheduleDataList = scheduleState.scheduleDataList + (schedule
//                        ?: continue)  // Safely add schedule to the list
//                )
//            }
//
//            scheduleState = scheduleState.copy(
//                isLoading = false
//            )
//        } catch (exception: Exception) {
//            Log.e("DataRead", "Failed to read schedule", exception)
//            scheduleState = scheduleState.copy(
//                isLoading = false,
//                error = true,
//                errorMessage = "Error Occurred while fetching schedule"
//            )
//        }
//    }
//
//private suspend fun get_schedule_list_string_from_uid(uid: String) {
//    try {
//        val user = database.reference.child("users").child(uid).get().await()
//            .getValue(user::class.java)
//        if (user != null) {
//            currentUser=user
//            scheduleListString = user.scheduleList
//        }
//    } catch (e: Exception) {
//        Log.d(
//            "Student Data",
//            "Error Occurred while retrieving schedule_list_string_from_uid $e"
//        )
//    }
//
//}
//
//suspend fun getCycles():MutableList<Cycle>?
//{
//    var allCyclesData: MutableList<Cycle> = mutableListOf()
//
//    val cycleref = database.reference.child("Cycle").get().await()
//    var cycleList: List<Cycle>? = null
//
//    if (cycleref.exists()) {
//        cycleList = cycleref.children.mapNotNull { it.getValue(Cycle::class.java) }
//    }
//
//    if (cycleList != null) {
//        for (cycles in cycleList) {
//            // Process each cycle object here
//            Log.d("Cycles", cycles.CycleId)
//            allCyclesData.add(cycles)
//        }
//    }
//    if(allCyclesData.isEmpty())
//        return null
//    else return allCyclesData
//}
//}


